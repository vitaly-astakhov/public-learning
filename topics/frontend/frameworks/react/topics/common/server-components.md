# Server components

## Materials

- [x] [RFC: React Server Components [github.com]](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md)
- [] [RSC From Scratch. Part 1: Server Components [github.com]](https://github.com/reactwg/server-components/discussions/5)
- [] [Making Sense of React Server Components](https://www.joshwcomeau.com/react/server-components/)

## Overview

Серверные Компоненты (***server components***) позволяют разработчикам создавать приложения, объединяющие сервер и клиент, сочетая богатую интерактивность клиентских приложений с улучшенной производительностью традиционного серверного рендеринга:

- Серверные Компоненты выполняются только на сервере и не оказывают никакого влияния на размер пакета. Их код никогда не загружается на клиентские серверы, что помогает уменьшить размер пакета и сократить время запуска. Подробнее: [Zero-Bundle-Size Components](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#zero-bundle-size-components), [Automatic Code Splitting](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#automatic-code-splitting)
- Серверные Компоненты могут получать доступ к серверным источникам данных, таким как базы данных, файловые системы или (микро)сервисы. Подробнее: [Full Access to the Backend](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#full-access-to-the-backend)
- Серверные Компоненты легко интегрируются с Клиентскими Компонентами, то есть с традиционными компонентами React.
- Серверные Компоненты могут загружать данные на сервер и передавать их в качестве реквизита Клиентским Компонентам, позволяя клиенту обрабатывать рендеринг интерактивных частей страницы.
- Серверные Компоненты могут динамически выбирать, какие Клиентские Компоненты отображать, что позволяет клиентам загружать только минимальный объем кода, необходимый для отображения страницы.
- Серверные Компоненты сохраняют состояние клиента при перезагрузке. Это означает, что состояние клиента, фокус и даже текущая анимация не нарушаются и не сбрасываются при повторной загрузке дерева Серверных Компонентов.
- Серверные Компоненты визуализируются постепенно, и пользовательский интерфейс передается клиенту в потоковом режиме. В сочетании с режимом ожидания (`Suspense`) это позволяет разработчикам создавать преднамеренные состояния загрузки и быстро показывать важный контент, ожидая загрузки оставшейся части страницы.
- Разработчики также могут совместно использовать код между сервером и клиентом, позволяя использовать один компонент для отображения статической версии некоторого контента на сервере по одному маршруту и редактируемой версии этого контента на клиенте по другому маршруту.

### [Capabilities & Constraints of Server and Client Components](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#capabilities--constraints-of-server-and-client-components)

<!--
Немного странно, что документ "RFC: React Server Components" не устанавливает чёткие ограничения на поведение серверных и клиентских компонентов. В секции "Capabilities & Constraints of Server and Client Components" используются условные формулировки "may" или "may not", вместо категоричных "MUST" или "MUST NOT", как это принято в RFC документах.
Отсутствие строгих вносит неопределённость в понимание требований к поведению компонентов.
-->

- **Server components** (Серверные Компоненты): Как правило, Серверные Компоненты запускаются *один раз для каждого запроса* на *сервере*, поэтому они не имеют состояния (*state*) и не могут использовать функции, которые существуют только на клиенте. В частности, Серверные Компоненты:
  - ❌ Не могут (*may not*) использовать state, поскольку они выполняются (концептуально) только один раз за запрос на сервере. Поэтому `useState()` и `useReducer()` не поддерживаются.
  - ❌ Не могут (*may not*) использовать жизненный цикл рендеринга (эффекты). Таким образом, `useEffect()` и `useLayoutEffect()` не поддерживаются.
  - ❌ Не могут (*may not*) использоваться API-интерфейсы только для браузера, такие как DOM (если вы не заполните их на сервере).
  - ❌ Не могут (*may not*) использовать кастомные хуки (*custom hooks*), зависящие от состояния или эффектов, или служебные функции, зависящие от API-интерфейсов только для браузера.
  - ✅ Могут (*may*) использовать `async / await` с источниками данных только для сервера, такими как базы данных, внутренние (микро) сервисы, файловые системы и т.д.
  - ✅ Могут (*may*) отображать другие Серверные Компоненты, собственные элементы (`<div>`, `<span>` и т.д.) или Клиентские Компоненты.
  - **Server Hooks/Utilities**: Разработчики также могут создавать кастомные хуки (*custom hooks*) или служебные библиотеки (*utility libraries*), предназначенные для сервера. Применяются все правила для Серверных Компонентов. Например, одним из вариантов использования серверных перехватчиков является предоставление помощников для доступа к источникам данных на стороне сервера.
- **Client Components** (*Клиентские Компоненты*): Это стандартные компоненты React, поэтому все правила, к которым вы привыкли, применяются. Основные новые правила, которые следует учитывать, - это то, чего они не могут делать в отношении серверных компонентов. Клиентские компоненты:
  - ❌ Не могут (*may not*) импортировать серверные компоненты или вызывать серверные хуки/утилиты, потому что они работают только на сервере
    - Однако Серверный Компонент может (*may*) передавать другой Серверный Компонент в качестве дочернего Клиентскому Компоненту: `<ClientTabBar><ServerTabContent /></ClientTabBar>`. С точки зрения Клиентского Компонента, его дочерним элементом будет уже отображенное дерево, такое как выходные данные ServerTabContent. Это означает, что серверный и клиентский компоненты могут быть вложены и чередоваться в дереве на любом уровне.
    <!-- Не понимаю это противоречие -->
  - ❌ Не могут (*may not*) использовать серверные источники данных.
  - ✅ Могут (*may*) использовать состояние.
  - ✅ Могут (*may*) использовать эффекты.
  - ✅ Могут (*may*) использовать браузерные API-интерфейсы (*browser-only APIs*).
  - ✅ Могут (*may*) использовать кастомные хуки и утилиты, которые используют состояние, эффекты или API-интерфейсы только для браузера.

#### [Sharing Code Between Server and Client](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#sharing-code-between-server-and-client)

В дополнение к чисто Серверным Компонентам и Клиентским Компонентам разработчики могут также создавать компоненты и хуки, которые работают как на сервере, так и на клиенте. Это позволяет совместно использовать логику в разных средах при условии, что компоненты соответствуют всем ограничениям как серверных, так и клиентских компонентов. Следовательно, общие компоненты и хуки:

- ❌ Не могут (*may not*) использовать состояние.
- ❌ Не могут (*may not*) использовать хуки жизненного цикла рендеринга, такие как эффекты.
- ❌ Не могут (*may not*) использовать API-интерфейсы только для браузера (*browser-only APIs*).
- ❌ Не могут (*may not*) использовать кастомные хуки или утилиты, зависящие от состояния, эффектов или API-интерфейсов браузера.
- ❌ Не могут (*may not*) использовать серверные источники данных.
- ❌ Не могут (*may not*) отображать Серверные Компоненты или использовать серверные хуки.
- ✅ Могут (*may*) использоваться как на сервере, так и на клиенте.
